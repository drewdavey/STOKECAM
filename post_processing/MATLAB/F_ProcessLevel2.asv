% STOKECAM Post-Processing
% Drew Davey
% Last updated: 2025-01-14

clear; clc; close all;

addpath('functions/');

%% Inputs

g = 9.81;     % gravity

dX = 0.1;     % X step size for plotting (meters)
dY = 0.1;     % Y step size for plotting (meters)
dZ = 0.1;     % Z step size for plotting (meters)

%% Filepath

% Load path to dir to reconstruct
session = uigetdir('../../../FSR/stereo_cam/DATA/','Select path to session containing wave subfolders'); 

% Find subfolders that start with "wave"
waveSubfolders = dir(fullfile(session, 'wave*'));

% Initialize waves array
waves = {};

% Loop over each matching entry
for i = 1:numel(waveSubfolders)
    if waveSubfolders(i).isdir
        % Build full path to subfolder
        wavePath = fullfile(session, waveSubfolders(i).name);
        % Append to the cell array
        waves{end + 1} = wavePath;
    end
end

% Process each selected path
for m = 1:length(waves)
    wave = waves{m};
    dir1 = dir([wave '/cam0/*.jpg']); 
    dir2 = dir([wave '/cam1/*.jpg']); 

    %% Create dirs and load L1 data
    L1Dir = [wave '/L1'];
    L2Dir = [wave '/L2'];
    figDir = [wave '/figs'];
    shapesDir = [figDir '/shapes'];
    
    if exist(L1Dir, 'dir')
        % Load L1 mats directory
        matDir = [L1Dir '/mats'];
        matFiles = dir(fullfile(matDir, '*.mat'));
        matFilenames = {matFiles.name};
        % Load IMU data
        load(fullfile(L1Dir, 'imu.mat'));
        % Relative time
        t = imu.t0;
    else
        disp('No L1 directory for this wave.');
        return;
    end
    if ~exist(L2Dir, 'dir')
        mkdir(L2Dir); % mkdir for L2
    end
    if ~exist(figDir, 'dir')
        mkdir(figDir); % mkdir for figs
    end
    if ~exist(shapesDir, 'dir')
        mkdir(shapesDir);  % Create shapes/ directory if it doesn't exist
    end
    
    %% Georectification
    % Convert geodetic to UTM
    [E, N, zone] = deg2utm(imu.lat, imu.lon); % Easting, Northing

    % LL to XY SIO
    [xSIO, ySIO] = lltoxy_siopier(imu.lat, imu.lon);
    
    % Geoid height correction 
    geoidHeight = geoidheight(imu.lat(1), imu.lon(1), 'EGM96'); 
    U = imu.alt - geoidHeight; % Up
    
    %% Compute rotation matrix from quaternion
    numFrames = numel(imu.quatX);
    rotationMatrices = zeros(3, 3, numFrames);
    for i = 1:numFrames
        qx = imu.quatX(i);
        qy = imu.quatY(i);
        qz = imu.quatZ(i);
        qw = imu.quatW(i);
        rotationMatrices(:, :, i) = quat2rotm([qw, qx, qy, qz]);
    end

    % %% Compute rotation matrix from Yaw-Pitch-Roll (3-2-1 sequence)
    % numFrames = numel(imu.yaw);
    % rotationMatrices = zeros(3, 3, numFrames);
    % imu.yaw = imu.yaw + 180;
    % imu.yaw = mod(imu.yaw, 360);
    % for i = 1:numFrames
    %     yaw = deg2rad(imu.yaw(i));   % Yaw (rotation around Z-axis)
    %     pitch = deg2rad(imu.pitch(i));  % Pitch (rotation around Y-axis)
    %     roll = deg2rad(imu.roll(i));    % Roll (rotation around X-axis)
    %     % Compute rotation matrix using 3-2-1 (Z-Y-X) Euler sequence
    %     Rz = [cos(yaw), -sin(yaw), 0;
    %           sin(yaw),  cos(yaw), 0;
    %                 0,        0,  1];  % Yaw (Z-axis)
    %     Ry = [ cos(pitch), 0, sin(pitch);
    %                    0, 1,          0;
    %           -sin(pitch), 0, cos(pitch)];  % Pitch (Y-axis)
    %     Rx = [1,        0,         0;
    %           0, cos(roll), -sin(roll);
    %           0, sin(roll),  cos(roll)];  % Roll (X-axis)
    %     % Final rotation matrix (Z-Y-X sequence)
    %     rotationMatrices(:, :, i) = Rz * Ry * Rx;
    % end
    
    %% Plot X-Y cross sections
    for i = 1:length(matFilenames)
        matData = load(fullfile(matDir, matFilenames{i}));
        if isfield(matData, 'points3D') && (isfield(matData, 'clean') && matData.clean == true)

            %%%%%%%%%%%%%% Point cloud in camera reference frame %%%%%%%%%%%%%%
            xyz_cam = matData.points3D;
            % xyz_cam = [xyz_cam(:,1), xyz_cam(:,2), xyz_cam(:,3)];

            % %%%%%%%%%% TRANSLATE HERE? %%%%%%%%%%%
            % f = 1.727174826954456;
            % f = 3;
            % xyz_cam = [xyz_cam(:,1) + 0.06, xyz_cam(:,2) - 0.06, xyz_cam(:,3) - f];
            % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

            figure(21); hold on; axis equal; grid on; axis tight;
            title('Camera coordinates');
            % scatter3(xyz_cam(:,1), xyz_cam(:,2), xyz_cam(:,3), 1);
            scatter(xyz_cam(:,1), xyz_cam(:,2), 1, xyz_cam(:,3));
            xlabel('X_{cam} (m)');
            ylabel('Y_{cam} (m)');
            zlabel('Z_{cam} (m)');
            cbar = colorbar; % Add colorbar and set its label
            cbar.Label.String = 'Z_{cam} (m)';  % Label for the colorbar
    
            %%%%%%%%%%%%%% Rotate into IMU coords: XYZ_imu = +Z+X+Y_cam %%%%%%%%%%%%%%
            xyz_imu = ([0 0 1; 1 0 0; 0 1 0] * xyz_cam')'; 
            % xyz_imu = [xyz_cam(:,3), xyz_cam(:,1), xyz_cam(:,2)];
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

            % %%%%%%%%%% TRANSLATE HERE? %%%%%%%%%%%
            % f = 3;
            % xyz_imu = [xyz_imu(:,1) - f, xyz_imu(:,2) - 0.06, xyz_imu(:,3) - 0.06];
            % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

            figure(22); hold on; axis equal; grid on; axis tight;
            title('imu coord.');
            scatter3(xyz_imu(:,1), xyz_imu(:,2), xyz_imu(:,3), 1);
            % scatter(xyz_imu(:,1), xyz_imu(:,2), 1, xyz_imu(:,3));
            xlabel('X imu');
            ylabel('Y imu');
            zlabel('Z imu');
    
            %%%%%%%%%%%%%%%%%%%%%% Rotation matrix %%%%%%%%%%%%%%%%%%%%%%%%%%%%
            R = rotationMatrices(:, :, i);

            % % Rotate about centroid???
            % centroid = mean(xyz_imu, 1, 'omitnan');
            % xyz_imu_rel =  xyz_imu - centroid;      % Move to centroid
            % xyz_NED = (R * xyz_imu_rel')';          % Rotate about centroid
            % centroid_rot = (R * centroid')';        % Rotate centroid itself
            % xyz_NED = xyz_NED + centroid_rot;       % Add it back

            % Rotate and transpose
            xyz_NED = (R * xyz_imu')';
    
            figure(23); hold on; axis equal; grid on; axis tight;
            title('rotated into NED');
            xlabel('Easting (m)'); ylabel('Northing (m)'); zlabel('D world');
            % scatter3(xyz_NED(:,2), xyz_NED(:,1), xyz_NED(:,3),...
            %     1, double(matData.colors) / 255, 'filled');
            scatter3(xyz_NED(:,2), xyz_NED(:,1), xyz_NED(:,3), 1);
    
            % Origin
            % cam_origin = [E(i), N(i), U(1)]; % ENU?
            % cam_origin = [N(i), E(i), -U(1)]; % NED?
            cam_origin = [ySIO(i), xSIO(i), U(1)]; % XY_SIO and Up 
            % cam_origin = [ySIO(1), xSIO(1), U(1)]; % XY_SIO and Up 
    
            %%%%%%%%%%%%%%%%%% Translate to world coord %%%%%%%%%%%%%%%%%%%%%%%
            xyz_world = -xyz_NED + cam_origin;
            % xyz_world = cam_origin + xyz_NED;

            %%% Heading dependent?
            % xyz_world = zeros(size(xyz_NED));
            % xyz_world(:,1) = xyz_NED(:,1) - cam_origin(:,1); % Northing
            % xyz_world(:,2) = xyz_NED(:,2) - cam_origin(:,2); % Easting
            % xyz_world(:,3) = xyz_NED(:,3) + cam_origin(:,3); % Down
            
            figure(24); hold on; axis equal; grid on; axis tight;
            title('World coordinates');
            % scatter3(xyz_world(:,2), xyz_world(:,1), xyz_world(:,3),...
            %     1, double(matData.colors) / 255, 'filled');
            % xlabel('Easting (m)'); ylabel('Northing (m)'); zlabel('D world');
            scatter3(xyz_world(:,2), xyz_world(:,1), -xyz_world(:,3), 1);
            xlabel('X_{SIO} (m)', 'FontSize', 12);
            ylabel('Y_{SIO} (m)', 'FontSize', 12);
            zlabel('Z_{NAVD88} (m)', 'FontSize', 12);
    
            % view(-64,16);
            % view(-164,10);
            
            % % Save the figure in the shapes/ directory
            % print(gcf, fullfile(shapesDir, [matFiles(i).name(end-8:end-4)]),...
            %     '-dpng', ['-r', num2str(res)]);

        end
    end

    % close all; % close figs before next wave

    % %% Plot rotations/translations
    % % Create points
    % depth = 2;
    % pointColors = {'r', 'g', 'b', 'm'};    % Corner colors
    % points = [depth, depth, depth, depth;  % X-coordinates
    %           0.5, -0.5, -0.5,  0.5;       % Y-coordinates
    %           0.5,  0.5, -0.5, -0.5];      % Z-coordinates
    % video = VideoWriter(fullfile(figDir, '3D_Orientation_with_Plane.mp4'), 'MPEG-4');
    % video.FrameRate = 1;
    % open(video);
    % figure;
    % xlabel('X'); ylabel('Y'); zlabel('Z');
    % grid on;
    % hold on;
    % % Set axis limits
    % range = depth*1.5;
    % axisLimits = [min(xm)-range, max(xm)+range, min(ym)-range, max(ym)+range, min(zm)-range, max(zm)+range];
    % for k = 1:numFrames
    %     cla;
    %     origin = [ySIO(i), xSIO(i), zm(1)];                 % Origin
    %     R = rotationMatrices(:, :, k);                      % Rotation matrix 
    %     rotated = R * points;                               % Rotate the points
    %     translated = rotated + origin';       % Translate the points 
    %     % Plot the camera axes 
    %     xAxis = R * [1; 0; 0];
    %     yAxis = R * [0; 1; 0];
    %     zAxis = R * [0; 0; 1];
    %     quiver3(xm(k), ym(k), zm(k), xAxis(1), xAxis(2), xAxis(3), 'r', 'LineWidth', 2);
    %     quiver3(xm(k), ym(k), zm(k), yAxis(1), yAxis(2), yAxis(3), 'g', 'LineWidth', 2);
    %     quiver3(xm(k), ym(k), zm(k), zAxis(1), zAxis(2), zAxis(3), 'b', 'LineWidth', 2);
    %     % Shade the plane
    %     fill3(translated(1, :), translated(2, :), translated(3, :), ...
    %           'k', 'FaceAlpha', 0.5, 'EdgeColor', 'none');
    %     for j = 1:4
    %         scatter3(translated(1, j), translated(2, j), translated(3, j), ...
    %                  10, pointColors{j}, 'filled');
    %     end
    %     axis equal; axis(axisLimits); title(['Frame ', num2str(k)]); drawnow;
    %     % pause(0.01);
    %     frame = getframe(gcf); writeVideo(video, frame); % Write frame to video
    % end
    % close(video);
end
