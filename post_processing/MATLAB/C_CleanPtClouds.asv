% STOKECAM Post-Processing
% Drew Davey
% Last updated: 2024-10-10

clear; clc; close all;

addpath('functions/');

%% Inputs

trimFlag = 1;       % trim to bbox?               
colorThresh = 1;    % filter by RGB thresholds?
manualFlag = 0;     % manually clean 

bounds = [-10 10 -10 10 0 30];   % [xmin xmax ymin ymax zmin zmax] for trimming points (meters)

%% Filepath

path = uigetdir('../../../FSR/stereo_cam/DATA/','Select path to session to clean ptClouds'); % load path to dir to clean ptClouds

matDir = [path '/mats'];
if ~exist(matDir, 'dir')
    disp('No mats/ directory in this session.');
    return;
end

%% Process ptClouds

cleanFlag = 1; 
while cleanFlag
    % Choose point cloud
    file = uigetfile([path '/Rectified_Images/*.png'],'Select file to view point cloud');
    file = file(1:end-9);
    
    % Load mat
    matFile = [matDir '/' file '.mat'];
    fprintf('Processing file: %s\n', matFile);
    load(matFile);

    % Timestamp prior to changes
    timestamp = datestr(datetime('now'), 'yyyymmdd_HHMMSS');
    
    % Create new variable names with timestamps
    data.(['points3D_', timestamp]) = data.points3D;
    data.(['ptCloud_', timestamp]) = data.ptCloud;
    data.(['colors_', timestamp]) = data.colors;
    data.bounds = bounds;

    %%%%%%%%%%%%%%%%%%%%%%%%%%% Apply QA/QC %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    if trimFlag
        [data.points3D, data.colors] = trimBounds(data.points3D, data.colors, data.bounds); % Trim to bounds
    
        % Remove rows where any of the columns in points3D have NaNs
        validRows = all(~isnan(data.points3D), 2);  % Find rows where all x, y, z values are non-NaN
    
        % Keep only the valid rows in points3D and corresponding colors
        data.points3D = data.points3D(validRows, :);  % Remove rows with NaNs in points3D
        data.colors = data.colors(validRows, :);  % Keep corresponding color rows
    
        data.ptCloud = pointCloud(data.points3D, 'Color', data.colors);
        data.ptCloud = pcdenoise(data.ptCloud);
    end

    if colorThresh
        % Load image
        figure; imshow(I1); 
        hold on;
        
        % Arrays to store all pixel values from foreground and background ROIs
        foregroundPixels = [];
        backgroundPixels = [];
        
        for i = 1:6
            % Determine title and color based on selection number
            if i <= 3
                title('Select Foreground ROI');
                color = 'g';  % Green for foreground
            else
                title('Select Background ROI');
                color = 'r';  % Red for background
            end
            
            h = drawrectangle('Color', color); % Draw rectangle
            position = h.Position; % [x, y, width, height]
    
            % Convert position to integer indices
            x1 = round(position(1));
            y1 = round(position(2));
            x2 = x1 + round(position(3)) - 1;
            y2 = y1 + round(position(4)) - 1;
            centerX = x1 + (x2 - x1) / 2;
            centerY = y1 + (y2 - y1) / 2;
    
            % Extract the region of interest
            roi = I1(y1:y2, x1:x2, :);
    
            % Accumulate all pixel values from the selected regions
            if i <= 3
                foregroundPixels = [foregroundPixels; reshape(roi, [], 3)];
            else
                backgroundPixels = [backgroundPixels; reshape(roi, [], 3)];
            end
    
            % Plot shaded rectangle
            fill([x1 x2 x2 x1], [y1 y1 y2 y2], color, 'FaceAlpha', 0.3, 'EdgeColor', color);
            text(centerX, centerY, sprintf('ROI %d', i), 'Color', color, 'FontSize', 10);
    
            pause(1); % Pause to view rectangle
        end
        
        % Calculate mean and standard deviation for each color channel
        foregroundMeanRGB = mean(foregroundPixels);
        foregroundStdRGB = std(double(foregroundPixels));
        backgroundMeanRGB = mean(backgroundPixels);
        backgroundStdRGB = std(double(backgroundPixels));
        N = 2; % Multiplier (N std from mean)
        
        % Define thresholds based on the combined foreground and background regions
        foregroundThresholds = [foregroundMeanRGB - N * foregroundStdRGB; foregroundMeanRGB + N * foregroundStdRGB];
        backgroundThresholds = [backgroundMeanRGB - N * backgroundStdRGB; backgroundMeanRGB + N * backgroundStdRGB];
        
        % Apply thresholding: Keep points within the foreground thresholds and exclude those within background thresholds
        fgIdx = (data.colors(:,1) >= foregroundThresholds(1,1) & data.colors(:,1) <= foregroundThresholds(2,1)) & ...
                (data.colors(:,2) >= foregroundThresholds(1,2) & data.colors(:,2) <= foregroundThresholds(2,2)) & ...
                (data.colors(:,3) >= foregroundThresholds(1,3) & data.colors(:,3) <= foregroundThresholds(2,3));
    
        bgIdx = (data.colors(:,1) >= backgroundThresholds(1,1) & data.colors(:,1) <= backgroundThresholds(2,1)) & ...
                (data.colors(:,2) >= backgroundThresholds(1,2) & data.colors(:,2) <= backgroundThresholds(2,2)) & ...
                (data.colors(:,3) >= backgroundThresholds(1,3) & data.colors(:,3) <= backgroundThresholds(2,3));
    
        % Filter out background points and keep foreground points
        data.colors = data.colors(fgIdx & ~bgIdx, :);
        data.points3D = data.points3D(fgIdx & ~bgIdx, :);
    
        % Write updated point cloud
        data.ptCloud = pointCloud(data.points3D, 'Color', data.colors);
        data.clean = 1;
    
        close(gcf);
    end

    if manualFlag
        % Create a 3D scatter plot with the points and colors
        f = figure;
        p = scatter3(data.points3D(:,1), data.points3D(:,2), data.points3D(:,3), 1, double(data.colors) / 255, 'filled');
        xlabel('X'); ylabel('Y'); zlabel('Z');
        title('Brush Data to Delete Points');

        % Initialize a logical array to keep track of all brushed points
        brushedIdx = false(size(data.points3D, 1), 1);

        % Enable data brushing for the figure
        brush on;

        while ishandle(f)
            newBrushedIdx = find(p.BrushData);  % Get the indices of brushed points
            brushedIdx(newBrushedIdx) = true;
            pause(0.1)
        end

        % Delete the brushed points
        data.points3D = data.points3D(~brushedIdx, :);
        data.colors = data.colors(~brushedIdx, :);

        % points3D(:,2) = -points3D(:,2);  % Flip the sign of the Y dimension
        % points3D(:,1) = -points3D(:,1);  % Flip the sign of the X dimension
        
        % Write updated ptCloud
        data.ptCloud = pointCloud(data.points3D, 'Color', data.colors);
        % Change clean flag
        data.clean = 1;

    end

    answer = questdlg('Save changes?', ...
    'Save changes', ...
    'Yes','No','Yes');
    switch answer
        case 'Yes'
            % Save updates
            save(matFile, 'data', '-append'); 
        case 'No'
            return 
    end

    answer = questdlg('Clean another point cloud?', ...
    'Clean another point cloud', ...
    'Yes','No','Yes');
    switch answer
        case 'Yes'
            cleanFlag = 1; 
        case 'No'
            cleanFlag = 0; 
    end
end