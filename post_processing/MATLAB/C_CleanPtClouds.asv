% STOKECAM Post-Processing
% Drew Davey
% Last updated: 2024-10-10

clear; clc; close all;

addpath('functions/');

%% Inputs

trimFlag = 1;       % trim to bbox?               
colorThresh = 1;    % filter by RGB thresholds?
manualFlag = 0;     % manually clean 

bounds = [-10 10 -10 10 0 30];   % [xmin xmax ymin ymax zmin zmax] for trimming points (meters)

%% Filepath
path = uigetdir('../../../FSR/stereo_cam/DATA/','Select path to session to clean ptClouds'); % load path to dir to clean ptClouds
%%%%               ^^^^^^^^^^^^ Queue up multiple dirs ^^^^^^^^^^^

matDir = [path '/mats'];
if ~exist(matDir, 'dir')
    disp('No mats/ directory in this session.');
    return;
end

%% Process ptClouds

cleanFlag = 1; 
while cleanFlag
    % Choose point cloud
    file = uigetfile([path '/Rectified_Images/*.png'],'Select file to view point cloud');
    file = file(1:end-9);
    
    % Load mat
    matFile = [matDir '/' file '.mat'];
    fprintf('Processing file: %s\n', matFile);
    load(matFile);

    % Timestamp prior to changes
    timestamp = datestr(datetime('now'), 'yyyymmdd_HHMMSS');
    
    % Create new variable names with timestamps
    data.(['points3D_', timestamp]) = data.points3D;
    data.(['ptCloud_', timestamp]) = data.ptCloud;
    data.(['colors_', timestamp]) = data.colors;
    data.bounds = bounds;

    %%%%%%%%%%%%%%%%%%%%%%%%%%% Apply QA/QC %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    if trimFlag
        [data.points3D, data.colors] = trimBounds(data.points3D, data.colors, data.bounds); % Trim to bounds
    
        % Remove rows where any of the columns in points3D have NaNs
        validRows = all(~isnan(data.points3D), 2);  % Find rows where all x, y, z values are non-NaN
    
        % Keep only the valid rows in points3D and corresponding colors
        data.points3D = data.points3D(validRows, :);  % Remove rows with NaNs in points3D
        data.colors = data.colors(validRows, :);  % Keep corresponding color rows
    
        data.ptCloud = pointCloud(data.points3D, 'Color', data.colors);
        data.ptCloud = pcdenoise(data.ptCloud);
    end

    if colorThresh
        % Load image
        figure; imshow(I1); 
        title('Select ROI for color thresholds');
        h = drawrectangle('Color', 'r'); % Creates an interactive rectangle with a red border
        position = h.Position; % [x, y, width, height]

        % Convert position to integer indices
        x1 = round(position(1));
        y1 = round(position(2));
        x2 = x1 + round(position(3)) - 1;
        y2 = y1 + round(position(4)) - 1;
        
        % Extract the region of interest
        roi = I1(y1:y2, x1:x2, :);

        % Calculate mean and standard deviation for each color channel
        meanRGB = mean(reshape(roi, [], 3));
        stdRGB = std(double(reshape(roi, [], 3)));
        N = 3; % multiplier (N std from mean)
        
        % Define thresholds
        redThreshold = [meanRGB(1) - N*stdRGB(1), meanRGB(1) + N*stdRGB(1)];
        greenThreshold = [meanRGB(2) - N*stdRGB(2), meanRGB(2) + N*stdRGB(2)];
        blueThreshold = [meanRGB(3) - N*stdRGB(3), meanRGB(3) + N*stdRGB(3)];
        
        % Apply threshold criteria for blue and green pixels
        blueGreenIdx = (data.colors(:,3) > blueThreshold(1) & data.colors(:,3) < blueThreshold(2)) & ...
                       (data.colors(:,2) > greenThreshold(1) & data.colors(:,2) < greenThreshold(2)) & ...
                       (data.colors(:,1) < min(data.colors(:,2), data.colors(:,3)));
    
        % Filter points that meet the criteria, retaining only blue/green points
        data.points3D = data.points3D(blueGreenIdx, :);
        data.colors = data.colors(blueGreenIdx, :);

        % Write updated ptCloud
        data.ptCloud = pointCloud(data.points3D, 'Color', data.colors);
        % Change clean flag
        data.clean = 1;

        close(gcf);
    end

    if manualFlag
        % Create a 3D scatter plot with the points and colors
        f = figure;
        p = scatter3(data.points3D(:,1), data.points3D(:,2), data.points3D(:,3), 1, double(data.colors) / 255, 'filled');
        xlabel('X'); ylabel('Y'); zlabel('Z');
        title('Brush Data to Delete Points');

        % Initialize a logical array to keep track of all brushed points
        brushedIdx = false(size(data.points3D, 1), 1);

        % Enable data brushing for the figure
        brush on;

        while ishandle(f)
            newBrushedIdx = find(p.BrushData);  % Get the indices of brushed points
            brushedIdx(newBrushedIdx) = true;
            pause(0.1)
        end

        % Delete the brushed points
        data.points3D = data.points3D(~brushedIdx, :);
        data.colors = data.colors(~brushedIdx, :);

        % points3D(:,2) = -points3D(:,2);  % Flip the sign of the Y dimension
        % points3D(:,1) = -points3D(:,1);  % Flip the sign of the X dimension
        
        % Write updated ptCloud
        data.ptCloud = pointCloud(data.points3D, 'Color', data.colors);
        % Change clean flag
        data.clean = 1;

    end

    answer = questdlg('Save changes?', ...
    'Save changes', ...
    'Yes','No','Yes');
    switch answer
        case 'Yes'
            % Save updates
            save(matFile, 'data', '-append'); 
        case 'No'
            return 
    end

    answer = questdlg('Clean another point cloud?', ...
    'Clean another point cloud', ...
    'Yes','No','Yes');
    switch answer
        case 'Yes'
            cleanFlag = 1; 
        case 'No'
            cleanFlag = 0; 
    end
end